# 파이썬 SW문제해결 응용_구현 - 05 백트래킹
# 5208. [파이썬

# sum : 배터리 잔량
def dfs(n, cnt, sum):
    global ans
    
    # 일단 가능한 모든 조건으로 진행한 다음, -> 이대로 하면 시간초과가 생김.
    # 백트래킹 조건 추가 -> 최소로 교환하기 때문에 현재 교환횟수가 기존 정답보다 커지면 할 필요가 없어짐.
    if ans <= cnt:
        return
 
    # 종료 조건 : 이동한 정류장 번호 = 정류장 개수 
    if n == N:
        ans = min(ans, cnt)             # 정답과 카운트 값을 가장 작은 값으로 교체
        return
 
    # 교환하는 경우
    dfs(n+1, cnt+1, lst[n]-1)
    # (정류장 번호 증가, 교체카운트+1), 교체한 배터리 용량-1)    

    # 교환하지 않는 경우: 배터리 잔량 있는 경우만 가능
    if sum > 0:                         # 내가 넘겨받은 잔량이 0이 아니면 넘어가기
        dfs(n+1, cnt, sum-1)       
        # (정류장 번호 증가, 교체카운트는 그대로(교체X), 잔량-1)    
 
T = int(input())
for test_case in range(1, T+1):
    lst = list(map(int, input().split()))
    N = lst[0]
    ans = N                             # 초기값. 모든 정류장에서 교체하는 경우,
 
    # 출발 정류장 번호, 
    dfs(2, 0, lst[1]-1)
    # (시작 정류장 번호, 교체 0, 시작 정류장 배터리-1)   
    print(f'#{test_case} {ans}')
